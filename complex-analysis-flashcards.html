<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complex Analysis Flashcards</title>
    <!-- 
        Complex Analysis Flashcards - Production Ready
        
        A fully self-contained, interactive flashcard application for studying 
        Complex Analysis concepts. Built with React 18, MathJax 3, and Tailwind CSS.
        
        Features:
        - 65+ flashcards covering comprehensive Complex Analysis topics
        - Dark/Light theme toggle
        - Progress tracking with visual feedback
        - Category filtering and shuffle mode
        - MathJax rendering for complex mathematical expressions
        - Responsive design for all devices
        - Local storage persistence
        
        To customize for other subjects:
        1. Update the CONFIG object below
        2. Replace flashcardsData with your content
        3. Modify categoryColors for your categories
        4. Update MathJax macros if needed
    -->
    <meta name="description" content="Interactive flashcards for studying Complex Analysis concepts including complex differentiation, integration, Riemann mapping theory, and more.">
    <meta name="keywords" content="complex analysis, mathematics, flashcards, study tools, analytic functions">
    <meta name="author" content="Complex Analysis Study Tools">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üìö</text></svg>">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: true,
                processEnvironments: true,
                macros: {
                    defeq: ":=",
                    textit: ["\\textit{#1}", 1]
                }
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                processHtmlClass: 'tex2jax_process',
                ignoreHtmlClass: 'tex2jax_ignore'
            },
            startup: {
                typeset: false,
                ready: () => {
                    console.log('MathJax is loaded and ready');
                    MathJax.startup.defaultReady();
                }
            },
            loader: {
                load: ['[tex]/color', '[tex]/colorv2']
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-size: 18px;
            color: #666;
        }
        .error {
            color: red;
            padding: 20px;
            margin: 20px;
            border: 1px solid red;
            border-radius: 5px;
            background-color: #fee;
        }
        
        .celebration-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
            overflow: hidden;
        }
        
        .confetti {
            position: absolute;
            font-size: 20px;
            user-select: none;
            pointer-events: none;
        }
        
        .confetti-explode {
            animation-duration: 2.5s;
            animation-timing-function: ease-out;
            animation-fill-mode: forwards;
        }
        
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: translateY(0);
            }
            40% {
                transform: translateY(-10px);
            }
            60% {
                transform: translateY(-5px);
            }
        }
        
        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.3);
            }
        }
        
        
        .confetti-bounce {
            animation: bounce 0.6s ease-in-out infinite;
        }
        
        .confetti-pulse {
            animation: pulse 1s ease-in-out infinite;
        }
        
        /* Ensure bold text is properly styled */
        strong {
            font-weight: 700 !important;
        }
        
        .font-semibold {
            font-weight: 600 !important;
        }
    </style>
</head>
<body>
    <div id="root">
        <div class="loading">
            <div>üìö Loading Complex Analysis Flashcards...</div>
            <div style="margin-top: 10px; font-size: 14px; color: #888;">
                Setting up React components and MathJax rendering...
            </div>
        </div>
    </div>

    <script>
        // Error handling
        window.onerror = function(msg, url, lineNo, columnNo, error) {
            console.error('Error: ', msg, '\nURL: ', url, '\nLine: ', lineNo, '\nColumn: ', columnNo, '\nError object: ', error);
            document.getElementById('root').innerHTML = '<div class="error">JavaScript Error: ' + msg + '</div>';
            return false;
        };
    </script>

    <script type="text/babel">
        try {
            const { useState, useEffect } = React;

            // ========================================
            // CONFIGURATION - Customize your flashcard app here
            // ========================================
            const CONFIG = {
                // App metadata
                APP_TITLE: 'Complex Analysis Flashcards',
                APP_DESCRIPTION: 'Interactive flashcards for Complex Analysis study',
                
                // Features
                ENABLE_DARK_MODE: true,
                ENABLE_PROGRESS_TRACKING: true,
                ENABLE_SHUFFLE: true,
                ENABLE_CATEGORY_FILTER: true,
                ENABLE_CELEBRATION: true,
                ENABLE_HIDE_ANSWER_TEXT: true,
                ENABLE_REVIEW_MODE: true,
                
                // UI settings
                CARDS_PER_PAGE: 1,
                AUTO_SAVE_PROGRESS: true,
                CONFETTI_DURATION: 2500,
                
                // Local storage keys (change if you want separate storage)
                STORAGE_PREFIX: 'complex_analysis_flashcards_',
                
                // MathJax settings
                MATHJAX_MACROS: {
                    defeq: ":=",
                    textit: ["\\textit{#1}", 1]
                }
            };

            // Simple icons as text
            const ChevronLeft = () => '‚Äπ';
            const ChevronRight = () => '‚Ä∫';
            const RotateCcw = () => '‚Üª';
            const BookOpen = () => 'üìñ';
            const Check = () => '‚úì';
            const X = () => '‚úó';
            const Eye = () => 'üëÅ';
            const EyeOff = () => 'üôà';
            const Shuffle = () => 'üîÄ';
            const Moon = () => 'üåô';
            const Sun = () => '‚òÄÔ∏è';

            // ========================================
            // FLASHCARDS DATA
            // ========================================
            const flashcardsData = [
                // Section 1: Basics
                {
                    id: 1,
                    category: "Basics",
                    front: "Define complex differentiation and analytic functions.",
                    back: "Consider $f\\colon U\\rightarrow \\mathbb{C}$ where $U\\subseteq \\mathbb{C}$ is open. Given $z\\in U$, we define $$f'(z) \\defeq \\lim_{h\\rightarrow 0} \\frac{f(z+h)-f(z)}{h}$$ If this limit exists, we say that $f$ is **differentiable** at $z$.\\n\\n We say $f\\colon U\\rightarrow \\mathbb{C}$ is **analytic** if $f'(z)$ exists, $\\forall z\\in U$."
                },
                {
                    id: 2,
                    category: "Basics",
                    front: "Define the Wirtinger derivatives.",
                    back: "Let $z=x+iy$ and $\\bar{z} = x-iy$. Then we have the differentials $$\\partial_z = \\tfrac{1}{2} (\\partial_x-i\\partial_y) \\text{ and } \\partial_{\\bar{z}} = \\tfrac{1}{2} (\\partial_x+i\\partial_y)$$"
                },
                {
                    id: 3,
                    category: "Basics",
                    front: "State the equivalent conditions for analyticity (Cauchy-Riemann).",
                    back: "If we write $z=x+iy$, then we can express $f(z)=u(x,y)+iv(x,y)$ for some real valued $u,v\\colon U\\rightarrow \\mathbb{R}$.\\n\\n The following are equivalent:\\n\\n1. $f$ is analytic\\n\\n2. $f$ satisfies the **Cauchy-Riemann equations**: $$u_x = v_y \\text{ and } u_y=-v_x$$\\n\\n3. $\\frac{\\partial f}{\\partial \\bar{z}}=0$"
                },
                {
                    id: 4,
                    category: "Basics",
                    front: "Define entire and conformal functions.",
                    back: "‚Ä¢ An analytic function $f\\colon U\\rightarrow \\mathbb{C}$ where $U=\\mathbb{C}$ is called an **entire function**.\\n\\n‚Ä¢ An analytic function $f\\colon U\\rightarrow \\mathbb{C}$ is **conformal** if $f'(z)\\neq 0$ on $U$."
                },
                {
                    id: 5,
                    category: "Basics",
                    front: "Define the radius of convergence of a power series. Give the formula for the derivative of a power series.",
                    back: "Let $f(z) = \\sum_{n=0}^\\infty a_n(z-z_0)^n$ be a formal power series centered at $z_0$. The **radius of convergence** $R$ is given by $$1/R = \\limsup_{n\\rightarrow \\infty} |a_n|^{1/n}.$$\\n\\n When $|z-z_0|<R$, the power series converges. When $|z-z_0|>R$, the power series diverges.\\n\\n**Properties**:\\n1. The series is absolutely convergent in $B(z_0, R)$ and uniformly absolutely convergent in $B(z_0, r)$ for $r<R$\\n\\n2. The series is analytic on $B(z_0, R)$ with derivative $$f'(z) = \\sum_{n=1}^\\infty n b_n(z-z_0)^{n-1}$$ where $b_n = \\frac{f^{(n)}(z_0)}{n!}$"
                },
                {
                    id: 6,
                    category: "Basics",
                    front: "Define the basic complex functions.",
                    back: "‚Ä¢ $\\exp(z) \\defeq \\sum_{n=0}^\\infty \\tfrac{z^n}{n!}$ has ROC $=\\infty$ and period $2\\pi i$\\n\\n‚Ä¢ $\\cos(z) \\defeq \\tfrac{\\exp(iz) + \\exp(-iz)}{2}$\\n\\n‚Ä¢ $\\sin(z) \\defeq \\tfrac{\\exp(iz) - \\exp(-iz)}{2i}$\\n\\n‚Ä¢ $\\log(z) \\defeq \\log|z| + i\\arg(z)$"
                },
                {
                    id: 7,
                    category: "Basics",
                    front: "Define a Riemann surface.",
                    back: "A **Riemann surface** is a Hausdorff complex $1$-manifold."
                },
                {
                    id: 8,
                    category: "Basics",
                    front: "What are the charts for the Riemann sphere $\\widehat{\\mathbb{C}}$? How is differentiability defined at $\\infty$ and at points where $f(z) = \\infty$?",
                    back: "‚Ä¢ $\\widehat{\\mathbb{C}} \\defeq \\mathbb{C} \\cup \\{\\infty\\}$ has the structure of a Riemann surface with an atlas of two charts: $(\\mathbb{C}, z)$ and $(\\mathbb{C}\\setminus \\{0\\} , 1/z)$\\n\\n‚Ä¢ We say that $f\\colon \\widehat{\\mathbb{C}} \\rightarrow \\widehat{\\mathbb{C}}$ is **differentiable at $\\infty$** if $f(1/z)$ is differentiable at $0$\\n\\n‚Ä¢ We say that $f\\colon \\widehat{\\mathbb{C}} \\rightarrow \\widehat{\\mathbb{C}}$ is **differentiable at $z$ where $f(z)=\\infty$** when $1/f(z)$ is differentiable at $z$"
                },
                {
                    id: 9,
                    category: "Basics",
                    front: "Define M√∂bius transformations.",
                    back: "‚Ä¢ $\\mathsf{Mob}^+ \\defeq \\left\\{f\\colon \\widehat{\\mathbb{C}} \\rightarrow \\widehat{\\mathbb{C}} \\; |\\;  f(z) = \\frac{az+b}{cz+d} \\; \\text{for } ad-bc\\neq 0\\right\\}$\\n\\n‚Ä¢ $\\mathsf{Mob} \\defeq \\left\\{f\\colon \\widehat{\\mathbb{C}} \\rightarrow \\widehat{\\mathbb{C}} \\; |\\;  f(z) = \\frac{az+b}{cz+d} \\; \\text{or} \\;  f(z) = \\frac{a\\bar{z}+b}{c\\bar{z}+d} \\; \\text{for } ad-bc\\neq 0\\right\\}$"
                },
                {
                    id: 10,
                    category: "Basics",
                    front: "Define extended circles and cross ratio.",
                    back: "**Extended Circles**: An extended circle in $\\widehat{\\mathbb{C}}$ is either $C\\subset \\mathbb{C}$ or $L\\cup \\{\\infty\\}$ for a circle/line (C/L) in $\\mathbb{C}$\\n\\n**Cross Ratio**: The cross ratio of a four-tuple is $$[z_1, z_2, z_3, z_4] \\defeq \\left( \\frac{z_1-z_3}{z_1-z_4}\\right) \\left( \\frac{z_2-z_4}{z_2-z_3}\\right)$$\\n\\n We observe that $T z_1 = [z_1, z_2, z_3, z_4]$ where $T\\colon (z_2, z_3, z_4) \\mapsto (1, 0, \\infty)$."
                },
                {
                    id: 11,
                    category: "Basics",
                    front: "State the uniqueness theorem for M√∂bius transformations.",
                    back: "Given $(z_1, z_2, z_3), (w_1, w_2, w_3)\\in \\widehat{\\mathbb{C}}$, there is a **unique** $T\\in \\mathsf{Mob}^+$ such that $T(z_i)=w_i, \\forall i$."
                },
                {
                    id: 12,
                    category: "Basics",
                    front: "State the classification of M√∂bius transformations.",
                    back: "Every M√∂bius transformation is conjugate to exactly one of the following:\\n\\n‚Ä¢ **Elliptic**: $S(z) = e^{i\\theta} z$\\n\\n‚Ä¢ **Hyperbolic**: $S(z) =\\lambda z$ for $|\\lambda|>1$\\n\\n‚Ä¢ **Parabolic**: $S(z) = z+1$"
                },
                {
                    id: 13,
                    category: "Basics",
                    front: "State the derivative formula for M√∂bius transformations.",
                    back: "For $f(z)=\\frac{az+b}{cz+d}$, we have $$f'(z) = \\frac{ad-bc}{(cz+d)^2}$$"
                },
                {
                    id: 14,
                    category: "Basics",
                    front: "What is the equation of an extended circle?",
                    back: "The equation of an extended circle is given by $a|z|^2+\\Re(bz) + c=0$ for $a,c\\in \\mathbb{R}$ and $b\\in \\mathbb{C}$."
                },
                {
                    id: 15,
                    category: "Basics",
                    front: "State key properties of M√∂bius transformations.",
                    back: "‚Ä¢ Let $T\\in \\mathsf{Mob}^+$. Then $T$ sends extended circles to extended circles\\n\\n‚Ä¢ Any $T\\in \\mathsf{Mob}^+$ is a composition of:\\n  - $f(z) = z+a$ (Translation)\\n  - $1/z$ (Inversion)\\n  - $g(z) = \\lambda z$ (Dilation)"
                },
                {
                    id: 16,
                    category: "Basics",
                    front: "State the cross ratio invariance property.",
                    back: "For $S\\in \\mathsf{Mob}^+$, we have $$[z_1, z_2, z_3, z_4]  = [Sz_1, Sz_2, Sz_3, Sz_4]$$\\n\\n This means **cross ratios are preserved** under M√∂bius transformations."
                },

                // Section 2: Integration
                {
                    id: 17,
                    category: "Integration",
                    front: "Define line and path integrals for complex functions.",
                    back: "‚Ä¢ Let $f\\colon [a,b]\\rightarrow \\mathbb{C}$ be given by $f(t) = u(t) + i v(t)$. Then $$\\int_a^b f(t) dt \\defeq \\int_a^b u(t) dt + i \\int_a^b v(t) dt$$\\n\\n‚Ä¢ Let $\\gamma\\colon [a,b]\\rightarrow \\mathbb{C}$ be a piecewise differentiable curve and $f\\colon \\gamma([a,b]) \\rightarrow \\mathbb{C}$ be continuous. Then $$\\int_\\gamma f(z) dz \\defeq \\int_a^b f(\\gamma(t)) \\gamma'(t) dt$$"
                },
                {
                    id: 18,
                    category: "Integration",
                    front: "Define the winding number.",
                    back: "Given a closed (piecewise smooth) curve $\\gamma$ and a point $p\\in \\mathbb{C}\\setminus \\gamma$, we define the **winding number** of $\\gamma$ around $p$ as $$n(\\gamma, p) \\defeq \\frac{1}{2\\pi i}\\int_\\gamma \\frac{1}{z-p} dz$$\\n\\n**Note**: $-n(\\gamma, p)= n(-\\gamma, p)$."
                },
                {
                    id: 19,
                    category: "Integration",
                    front: "Define isolated singularities and their classification.",
                    back: "If $f$ is analytic on $U-\\{p\\}$, then we obtain a **Laurent expansion** at $p$ $$f(z) = \\sum_{n=-\\infty}^\\infty a_n(z-p)^n$$ and we call $p$ an **isolated singularity**.\\n\\n**Classification** by $\\text{ord}(f,p)= \\inf\\{n\\in \\mathbb{Z} \\colon a_n\\neq 0\\}$:\\n\\n‚Ä¢ If $\\text{ord}(f,p) =-n< 0$: **pole of order** $n$\\n‚Ä¢ If $\\text{ord}(f,p) = n\\geq 0$: **removable singularity** and zero of order $n$\\n‚Ä¢ If $\\text{ord}(f,p)=-\\infty$: **essential singularity**"
                },
                {
                    id: 20,
                    category: "Integration",
                    front: "Define meromorphic functions and residues.",
                    back: "‚Ä¢ A function $f\\colon U\\to \\mathbb{C}$ is **meromorphic** if it is holomorphic on all of $U$ except for a set of isolated points, which are poles of the function.\\n\\n‚Ä¢ If $p$ is an isolated singularity of $f\\colon U\\to \\mathbb{C}$, we define $$\\text{Res}(f, p)\\defeq a_{-1}$$ where $f(z) = \\sum_{n=-\\infty}^\\infty a_n(z-p)^n$ is the Laurent series expansion around $p$."
                },
                {
                    id: 21,
                    category: "Integration",
                    front: "State Cauchy's Theorem.",
                    back: "Let $f\\colon U\\rightarrow \\mathbb{C}$ be analytic. Then:\\n\\n‚Ä¢ Let $T\\subseteq U$ be a triangle: $\\int_{\\partial T} f(z) dz =0$\\n\\n‚Ä¢ Let $P\\subseteq U$ be a polygon: $\\int_{\\partial P} f(z) dz = 0$\\n\\n‚Ä¢ Let $V\\subseteq \\mathbb{C}$ be open such that $\\overline{V}\\subseteq U$ is compact and $\\partial V$ is piecewise smooth: $$\\int_{\\partial V}f(z) dz = 0$$\\n\\n‚Ä¢ **General form**: Let $f\\colon U\\rightarrow \\mathbb{C}$ be analytic, and $\\gamma$ a cycle which is null-homologous in $U$. Then $$\\int_\\gamma f(z) dz =0$$"
                },
                {
                    id: 22,
                    category: "Integration",
                    front: "State Cauchy's Integral Formula.",
                    back: "A holomorphic function defined on a disk is completely determined by its values on the boundary of the disk.\\n\\n Let $f\\colon U\\rightarrow \\mathbb{C}$ be analytic with $\\overline{B(a, R)}\\subseteq U$. Then for $z\\in B(a, R)$: $$f(z) = \\frac{1}{2\\pi i} \\int_{C(a,R)} \\frac{f(w)}{w-z} dw$$"
                },
                {
                    id: 23,
                    category: "Integration",
                    front: "If $f: U \\to \\mathbb{C}$ is analytic and $a \\in U$, what can you say about the power series expansion of $f$ about $a$?",
                    back: "If $f: U \\to \\mathbb{C}$ is analytic and $a \\in U$, then $f$ is given by a power series about $a$ with radius of convergence $R = d(a, \\partial U)$. Furthermore, $f^{(n)}(z)$ is analytic on $U$ for all $n \\geq 0$.\\n\\n**Sketch of proof**:\\n1. By Cauchy's integral formula: $f^{(n)}(a) = \\frac{n!}{2\\pi i} \\int_{C(a,r)} \\frac{f(w)}{(w-a)^{n+1}} dw$ for any $r < d(a, \\partial U)$\\n2. The series $\\sum_{n=0}^{\\infty} \\frac{f^{(n)}(a)}{n!}(z-a)^n$ converges for $|z-a| < R = d(a, \\partial U)$\\n3. For any $z$ with $|z-a| < R$, choose $r$ with $|z-a| < r < R$. Then:\\n   $$f(z) = \\frac{1}{2\\pi i} \\int_{C(a,r)} \\frac{f(w)}{w-z} dw = \\sum_{n=0}^{\\infty} \\frac{f^{(n)}(a)}{n!}(z-a)^n$$\\n4. The derivatives $f^{(n)}$ are analytic as uniform limits of analytic functions on compact subsets."
                },
                {
                    id: 24,
                    category: "Integration",
                    front: "State the mean-value formula for analytic functions.",
                    back: "If $f$ is **analytic** on a domain $U$ and $\\overline{B(a,r)} \\subseteq U$, then $$f(a) = \\frac{1}{2\\pi} \\int_0^{2\\pi} f(a + re^{i\\theta}) d\\theta$$\\n\\n This says that $f(z)$ is the **average value** of $f$ over any circle centered at $z$ and contained in the domain.\\n\\n**Proof**: Apply Cauchy's integral formula with the parameterization $w = a + re^{i\\theta}$."
                },
                {
                    id: 25,
                    category: "Integration",
                    front: "State Liouville's Theorem.",
                    back: "If $f$ is a **bounded entire function**, then $f$ is **constant**.\\n\\n More generally, if $f$ is entire and $|f(z)| \\leq A +B|z|^n$, then $f$ is a polynomial of degree at most $n$."
                },
                {
                    id: 26,
                    category: "Integration",
                    front: "State the Identity Theorem.",
                    back: "Let $f\\colon U\\rightarrow \\mathbb{C}$ be analytic on $U$ connected. Then **TFAE**:\\n\\n1. $f\\equiv 0$\\n\\n2. $Z(f)$ has an accumulation point\\n\\n3. For some $a\\in U$, $f^{(n)}(a)=0, \\forall n$"
                },
                {
                    id: 27,
                    category: "Integration",
                    front: "State the Maximum Modulus Principle.",
                    back: "Let $f\\colon U\\rightarrow \\mathbb{C}$ be analytic and $U$ connected. If $f$ achieves its **maximum modulus** in $U$, then $f$ is **constant**.\\n\\n**Proof idea**: If $|f(z)|$ achieves its maximum at $a\\in U$, then by the mean value property, $f(a)$ equals the average of $f$ over small circles centered at $a$. This forces $f$ to be constant in a neighborhood of $a$, and by connectedness, everywhere."
                },
                {
                    id: 28,
                    category: "Integration",
                    front: "State Morera's Theorem.",
                    back: "If $f\\colon U\\rightarrow \\mathbb{C}$ is **continuous** and $\\int_\\gamma f(z)dz=0$ for all closed curves $\\gamma$ in $U$, then $f$ is **analytic**.\\n\\n**Proof idea**: Define $F(z) = \\int_{\\gamma_z} f(w)dw$ where $\\gamma_z$ is a path from a fixed point to $z$. The hypothesis ensures $F$ is well-defined, and by FTC, $F'(z) = f(z)$, so $f$ is holomorphic."
                },
                {
                    id: 29,
                    category: "Integration",
                    front: "State Weierstrass' Theorem on uniform convergence of analytic functions.",
                    back: "If $f_n\\colon U\\rightarrow \\mathbb{C}$ are **analytic** and **uniformly convergent to $f$ on compact subsets**, then $f\\colon U\\rightarrow \\mathbb{C}$ is **analytic**.\\n\\n**Proof**: By uniform convergence, $f$ is continuous. For a closed curve $\\gamma \\in U$: $$\\int_\\gamma f(z) dz = \\int_\\gamma \\lim_{n\\rightarrow \\infty} f_n(z)dz = \\lim_{n\\rightarrow \\infty} \\int_\\gamma f_n(z) dz = \\lim_{n\\rightarrow \\infty} 0 = 0$$\\n\\n Thus, $f$ is analytic by **Morera's Theorem**."
                },
                {
                    id: 30,
                    category: "Integration",
                    front: "State the Laurent Series Theorem.",
                    back: "Let $f\\colon U\\rightarrow \\mathbb{C}$ be analytic with $\\overline{A(a, r, R)} \\subseteq U$. Then on $A(a, r, R)$: $$f(z) = \\sum_{n=-\\infty}^\\infty a_n(z-a)^n = \\underbrace{\\sum_{n=1}^\\infty \\frac{b_n}{(z-a)^n}}_{\\text{singular part}} + \\underbrace{\\sum_{n=0}^\\infty a_n(z-a)^n}_{\\text{regular part}}$$\\n\\n The series is absolutely convergent in $A(a,r,R)$ and uniformly convergent on compact subsets.\\n\\n**Coefficients**: $$a_n = \\frac{1}{2\\pi i} \\int_{\\gamma} \\frac{f(w)}{(w-a)^{n+1}} dw$$"
                },
                {
                    id: 31,
                    category: "Integration",
                    front: "State the Residue Theorem.",
                    back: "Let $f\\colon U\\to \\mathbb{C}$ be analytic on $U$ outside of a finite set $\\{z_i\\}_{i=1}^m$ and $\\gamma$ a closed nullhomotopic path in $U$ which does not contain any of the $z_i$. Then $$\\int_\\gamma f(z) dz = 2\\pi i \\sum_{i=1}^m n(\\gamma, z_i) \\cdot \\text{Res}(f, z_i)$$\\n\\n Furthermore, if $\\overline{V}\\subseteq U$ and $\\partial V$ does not contain any $z_i$: $$\\int_{\\partial V} f(z) dz = 2\\pi i \\sum_{z_i\\in V} \\text{Res}(f, z_i)$$"
                },
                {
                    id: 32,
                    category: "Integration",
                    front: "State the Argument Principle.",
                    back: "Let $f\\colon U\\to \\mathbb{C}$ be meromorphic and $\\gamma$ a curve not containing any zeros or poles of $f$ that is nullhomotopic in $U$. Then $$\\sum_{p\\in U} n(\\gamma, p) \\text{ord}(f, p) = \\frac{1}{2\\pi i} \\int_\\gamma \\frac{f'(z)}{f(z)} dz$$\\n\\n**Note**: $\\text{Res}(f'/f, p) = \\text{ord}(f, p)$ for poles and zeros.\\n\\n**Proof**: We notice that if $f$ has at worst a pole at $p$ (not an essential singularity), then $f'/f$ satisfies $$\\text{Res}(f'/f, p) = \\text{ord}(f, p)$$\\n\\n Now apply the **Residue Theorem**."
                },
                {
                    id: 33,
                    category: "Integration",
                    front: "State Rouch√©'s Theorem.",
                    back: "If $f, g\\colon U\\rightarrow \\mathbb{C}$ are analytic, $\\overline{V}\\subseteq U$, and $|g(z)| < |f(z)|$ on $\\partial V$, then $f$ and $f+g$ have the **same number of zeros** in $V$ (counted with multiplicity).\\n\\n**Proof idea**: Since $|f|> |g|$ on $\\partial V$, for $t\\in [0, 1]$, $|f(z)+t g(z)|\\geq |f|-|g|>0$. By the Argument Principle, $N(f+tg, V)$ is a continuous integer-valued function on $[0,1]$, hence constant."
                },
                {
                    id: 34,
                    category: "Integration",
                    front: "State the Open Mapping Theorem.",
                    back: "Let $f\\colon U\\to \\mathbb{C}$ be a **non-constant analytic function**. Then $f$ is an **open map** (maps open sets to open sets).\\n\\n**Proof idea**: Let $p\\in U$ and $f(p)=q$. Since $f$ is non-constant, $f(z)-q$ has an isolated zero at $p$. Choose a small ball $V$ around $p$ such that $f(z) \\neq q$ on $\\partial V$. Then $f(V)$ contains the component of $\\mathbb{C}\\setminus f(\\partial V)$ containing $q$, so $f(U)$ is open."
                },
                {
                    id: 35,
                    category: "Integration",
                    front: "State the Fundamental Theorem of Algebra (complex analysis proof).",
                    back: "Every non-constant polynomial has a zero in $\\mathbb{C}$. Furthermore, any polynomial can be uniquely factored into linear functions over $\\mathbb{C}$.\\n\\n**Proof**: Suppose for contradiction $P$ is a non-constant polynomial with no zeros. Then $1/P$ is an entire function with $\\lim_{z\\rightarrow \\infty} 1/P(z) = 0$. So $1/P$ is an entire bounded function, hence constant by Liouville's Theorem. Therefore, $P$ is constant, contradiction."
                },
                {
                    id: 36,
                    category: "Integration",
                    front: "How do you calculate residues at poles?",
                    back: "**Simple pole**: $$\\text{Res}(f,p) = \\lim_{z\\to p}(z-p)f(z)$$\\n\\n**Simple pole from ratio**: If $f(z) = \\frac{g(z)}{h(z)}$ where $h(p) =0$ but $h'(p)\\neq 0$: $$\\text{Res}(f,p) = \\frac{g(p)}{h'(p)}$$\\n\\n**Pole of order $n$**: $$\\text{Res}(f, p) = \\frac{1}{(n-1)!} \\left( \\frac{d^{n-1}}{dz^{n-1}} [(z-p)^n f(z)]\\right)\\bigg|_{z=p}$$"
                },

                // Section 3: Riemann Mapping
                {
                    id: 37,
                    category: "Riemann Mapping",
                    front: "State the Schwarz Lemma.",
                    back: "Let $f: \\Delta \\rightarrow \\Delta$ be analytic with $f(0) = 0$. Then:\\n\\n‚Ä¢ $|f(z)| \\leq |z|$ for all $z \\in \\Delta$\\n\\n‚Ä¢ $|f'(0)| \\leq 1$\\n\\n**Equality case**: If equality holds for either at a nonzero point in the disc, then $f(z) = cz$ for some $|c| = 1$."
                },
                {
                    id: 38,
                    category: "Riemann Mapping",
                    front: "State the Schwarz Reflection Principle.",
                    back: "Let $U$ be open and symmetric about the $x$-axis, $U = V \\cup W \\cup A$, where $A = U \\cap \\mathbb{R}$, $V = U \\cap \\mathbb{H}$. Let $f : V \\to \\mathbb{C}$ be analytic and continuous on $V \\cup A$ with $f$ **real on $A$**. Then $f$ **extends** to an analytic function on $U$.\\n\\n**Extension**: On $W$ define $f(z) = \\overline{f(\\overline{z})}$."
                },
                {
                    id: 39,
                    category: "Riemann Mapping",
                    front: "State the Riemann Mapping Theorem.",
                    back: "A **simply connected** Riemann surface is isomorphic to exactly one of either $\\mathbb{C}$, $\\widehat{\\mathbb{C}}$, or $\\mathbb{H}$.\\n\\n**Normalization**: If $U \\neq \\mathbb{C}$ is a simply connected domain and $a \\in U$, then there is a **unique** bi-holomorphic conformal mapping $\\phi: U \\rightarrow \\Delta$ such that $\\phi(a) = 0$ and $\\phi'(a) > 0$."
                },
                {
                    id: 40,
                    category: "Riemann Mapping",
                    front: "State the Corollary to the Riemann Mapping Theorem.",
                    back: "If $U \\subset \\mathbb{C}$ is a **simply connected open set** which is **not the whole plane**, then $U$ is **biholomorphically equivalent** to the **unit disc** $\\Delta$.\\n\\n**Proof**: By the Riemann Mapping Theorem, $U$ is isomorphic to one of $\\mathbb{C}$, $\\widehat{\\mathbb{C}}$, or $\\mathbb{H}$. Since $U \\neq \\mathbb{C}$ and $U \\subset \\mathbb{C}$, we have $U \\not\\simeq \\mathbb{C}$ and $U \\not\\simeq \\widehat{\\mathbb{C}}$. Therefore $U \\simeq \\mathbb{H} \\simeq \\Delta$."
                },
                {
                    id: 41,
                    category: "Riemann Mapping",
                    front: "State the characterization of proper analytic functions.",
                    back: "An analytic function $f: \\mathbb{C} \\to \\mathbb{C}$ is **proper** $\\iff$ $f(z)$ is a **non-constant polynomial**.\\n\\n**Proof**:\\n\\n**($\\Rightarrow$)** Suppose $f$ is a proper analytic function.\\n\\n‚Ä¢ Since $f$ is analytic and proper, the preimage of any compact set is compact\\n‚Ä¢ The set of zeros of $f$, i.e., $f^{-1}(0)$, must be compact\\n‚Ä¢ But the zeros of a nonzero analytic function are isolated, so if there are infinitely many zeros, they must accumulate ‚Äî contradicting compactness of a discrete set\\n‚Ä¢ Hence, $f$ has only **finitely many zeros**\\n\\n Choose $R > 0$ so that all zeros of $f$ lie in $B(0, R)$. Define $$g(z) := \\frac{1}{f(1/z)}$$\\n\\n Then $g$ is analytic and nonzero on $0 < |z| < 1/R$, hence has at most a **removable singularity at 0**.\\n\\n Extend $g$ analytically to $z = 0$. Since $f$ has a zero at infinity, $g$ has a zero at 0 of some order $n$: $$g(z) = z^n h(z), \\quad \\text{with } h(0) \\neq 0$$\\n\\n Thus, $|g(z)| \\geq K |z|^n$ on $B(0, 1/R) \\setminus \\{0\\}$. Hence: $$|f(z)| = \\left| \\frac{1}{g(1/z)} \\right| \\leq \\frac{1}{K |1/z|^n} = \\frac{|z|^n}{K}, \\quad \\text{for } |z| > R$$\\n\\n This gives a **polynomial-type bound**: $|f(z)| \\leq A + B |z|^n$ for all $z$. By **Cauchy's estimate**, this implies that $f$ is a polynomial of degree at most $n$.\\n\\n**($\\Leftarrow$)** Conversely, any **nonconstant polynomial is proper**: the preimage of a compact set under a polynomial is bounded and closed (hence compact), because polynomial functions go to infinity as $|z| \\to \\infty$."
                },
                {
                    id: 42,
                    category: "Riemann Mapping",
                    front: "State the automorphism groups of Riemann surfaces.",
                    back: "‚Ä¢ $\\text{Aut}(\\widehat{\\mathbb{C}}) = \\mathsf{Mob}^+$ (M√∂bius transformations)\\n\\n‚Ä¢ $\\text{Aut}(\\mathbb{C}) = \\{f(z) = az + b : a \\neq 0, \\text{ and } a,b \\in \\mathbb{C}\\}$ (affine transformations)\\n\\n‚Ä¢ $\\text{Aut}(\\mathbb{H}) = \\mathsf{Mob}^+(\\mathbb{H}) = \\text{PSL}_2(\\mathbb{R})$ (real M√∂bius transformations)\\n\\n‚Ä¢ $\\text{Aut}(\\Delta) = \\text{PSU}(1,1) = \\{A\\in \\text{SL}(2,\\mathbb{C}) \\mid \\overline{A}^t Q A = Q\\}/\\{\\pm I\\}$ where $Q(z_1, z_2) = |z_1|^2-|z_2|^2$\\n\\n**Alternative description**: Every element of $\\text{Aut}(\\Delta)$ is given by $\\phi_a(z) = \\frac{z-a}{1-z\\overline{a}}$ for $a\\in \\Delta$.\\n\\n**Proof sketch**: If $\\phi \\in \\text{Aut}(\\Delta)$ with $\\phi(0) = a$, then $\\phi_a^{-1} \\circ \\phi$ fixes $0$. By Schwarz lemma, if $f: \\Delta \\to \\Delta$ is analytic with $f(0) = 0$, then $|f'(0)| \\leq 1$ with equality iff $f(z) = e^{i\\theta} z$. Since $\\phi_a^{-1} \\circ \\phi$ and its inverse are both disk automorphisms fixing $0$, we get $\\phi_a^{-1} \\circ \\phi(z) = e^{i\\theta} z$, so $\\phi(z) = \\phi_a(e^{i\\theta} z)$."
                },
                {
                    id: 43,
                    category: "Riemann Mapping",
                    front: "State the theorem about rational functions on the Riemann sphere.",
                    back: "Every non-constant analytic map $f: \\widehat{\\mathbb{C}} \\to \\widehat{\\mathbb{C}}$ is a **rational function**.\\n\\n**Proof**: By composing with a M√∂bius transformation if necessary, we may assume without loss of generality that $f(\\infty) = \\infty$.\\n\\nSince $f$ is analytic on the **compact Riemann sphere** $\\widehat{\\mathbb{C}}$, it cannot have any **essential singularities**: essential singularities are not isolated, and thus are incompatible with analyticity on a compact surface. Hence, all singularities of $f$ are **poles**.\\n\\nLet $\\{p_i\\}$ be the set of poles of $f$, and let $f_i$ be the **principal part** of the Laurent expansion of $f$ at $p_i$. Since $f$ is meromorphic on the compact sphere, $\\{p_i\\}$ must be a **finite set**; otherwise, the poles would accumulate and contradict the analyticity of $f$, forcing $f \\equiv \\infty$.\\n\\nDefine the function $$g(z) := f(z) - \\sum_i f_i(z)$$\\n\\nThen $g$ is **analytic on all of** $\\widehat{\\mathbb{C}}$, i.e., an entire function with no poles. Since $f(\\infty) = \\infty$, we see that $g(\\infty) = \\infty$, so $g$ is **proper**. Therefore, $g$ must be a **polynomial**.\\n\\nIt follows that $f = g + \\sum_i f_i$ is the sum of a polynomial and finitely many principal parts ‚Äî hence a **rational function**."
                },
                {
                    id: 44,
                    category: "Riemann Mapping",
                    front: "State the Monodromy Theorem.",
                    back: "Let $z_0 \\in U$ and $(f_0, U_0)$ be a function pair which may be analytically continued along all curves in $U$. Let $\\gamma_0, \\gamma_1: [0,1] \\to U$ be two curves from $z_0$ to $z_1$ **homotopic in $U$**. Let $(f_1, D_1)$ be analytic continuation of $(f_0, D_0)$ along $\\gamma_0$. Then analytic continuation along $\\gamma_1$ is **equivalent** to $(f_1, D_1)$."
                },
                {
                    id: 45,
                    category: "Riemann Mapping",
                    front: "Define analytic covering maps and universal covers.",
                    back: "**Analytic Covering Map**: If $X$ and $Y$ are Riemann surfaces, a map $\\pi: X \\to Y$ is an analytic covering map if it is a covering map such that at each point $p \\in Y$, there is an open neighborhood $U$ such that $\\pi^{-1}(U) = \\cup U_\\alpha$ where $\\pi|_{U_\\alpha}: U_\\alpha \\to U$ is a biholomorphism.\\n\\n**Universal Cover**: Given a Riemann surface $X$, there is a universal cover $\\pi: \\tilde{X} \\to X$ such that $X = \\tilde{X}/\\Gamma$ where $\\Gamma \\subseteq \\text{Aut}(\\tilde{X})$."
                },
                {
                    id: 46,
                    category: "Riemann Mapping",
                    front: "State the classification of universal covers.",
                    back: "If $X$ is a Riemann surface with universal cover $\\mathbb{C}$, then $X = \\mathbb{C}/\\Gamma$ where:\\n\\n‚Ä¢ $\\Gamma = \\langle z+1 \\rangle$ (cylinder/punctured plane), or\\n\\n‚Ä¢ $\\Gamma = \\langle z+1, z+\\tau \\rangle$ for $\\tau \\in \\mathbb{H}$ (torus)"
                },

                // Section 4: Conformal Geometry
                {
                    id: 47,
                    category: "Conformal Geometry",
                    front: "Define conformal metrics and geometric quantities.",
                    back: "A **conformal metric** $\\rho$ on a Riemann surface $X$ is given locally by $\\rho(z) |dz|$ where $\\rho: X \\to \\mathbb{R}_+$ is continuous.\\n\\n**Geometric Quantities**:\\n‚Ä¢ **Length**: $L_\\rho(\\gamma) = \\int_\\gamma \\rho(z) |dz|$\\n‚Ä¢ **Area**: $A_\\rho(U) = \\int_U \\rho^2(z) dx dy$\\n‚Ä¢ **Pullback metric**: $f^*(\\rho)(z)|dz| = \\rho(f(z)) |f'(z)| |dz|$\\n‚Ä¢ **Isometry**: $\\rho_1(z) = \\rho_2(f(z)) |f'(z)|$\\n‚Ä¢ **Gaussian curvature**: $K(\\rho) \\defeq -\\frac{\\Delta(\\log \\rho)}{\\rho^2}$ where $\\Delta$ is the **Laplacian**, defined as $\\Delta(u) = u_{xx} + u_{yy}$"
                },
                {
                    id: 48,
                    category: "Conformal Geometry",
                    front: "Define the standard conformal metrics.",
                    back: "**Euclidean/Flat metric** on $\\mathbb{C}$: $\\rho(z) = |dz|$\\n\\n**Spherical metric** on $\\widehat{\\mathbb{C}}$: $\\rho_{\\widehat{\\mathbb{C}}}(z) |dz| = \\frac{2 |dz|}{1+|z|^2}$\\n\\n**Hyperbolic metric on $\\mathbb{H}$**: $\\rho_{\\mathbb{H}}(z) = \\frac{1}{\\text{Im}(z)}$ giving distance $d_\\mathbb{H}(z, w) = \\left|\\frac{z-w}{z-\\overline{w}}\\right|$\\n\\n**Hyperbolic metric on $\\Delta$**: $\\rho_{\\Delta}(z) = \\frac{2}{1 - |z|^2}$ giving distance $d_{\\Delta}(z,w) = \\left|\\frac{z-w}{1-\\overline{w}z}\\right|$"
                },
                {
                    id: 49,
                    category: "Conformal Geometry",
                    front: "State the curvatures of the standard metrics.",
                    back: "‚Ä¢ **Flat metric**: $K = 0$ (since $\\log \\rho = \\log 1 = 0$)\\n\\n‚Ä¢ **Spherical metric**: $K = +1$\\n\\n‚Ä¢ **Hyperbolic metrics**: Both $\\rho_\\mathbb{H}$ and $\\rho_\\Delta$ have Gaussian curvature $K = -1$"
                },
                {
                    id: 50,
                    category: "Conformal Geometry",
                    front: "State the Schwarz-Pick Theorem.",
                    back: "If $f: \\Omega_1 \\to \\Omega_2$ is analytic, with $\\Omega_j \\in \\{\\Delta, \\mathbb{H}\\}$, then:\\n\\n‚Ä¢ **Distance decreasing**: $d_{\\Omega_2}(f(z), f(w)) \\leq d_{\\Omega_1}(z,w)$\\n\\n‚Ä¢ **Differential form**: $\\rho_{\\Omega_2}(f(z)) \\cdot |f'(z)| \\leq \\rho_{\\Omega_1}(z)$\\n\\n‚Ä¢ **Equality case**: If equality holds for some pair of distinct points (or one point with $f'(z) \\neq 0$), then $f$ is a M√∂bius transformation that is an isometry."
                },
                {
                    id: 51,
                    category: "Conformal Geometry",
                    front: "State the explicit Schwarz-Pick formulas for all cases.",
                    back: "From the distance decreasing property of analytic maps between hyperbolic spaces:\\n\\n**For $f\\colon \\Delta \\to \\Delta$**:\\n$$\\left|\\frac{f(z)-f(w)}{1-\\overline{f(w)}f(z)}\\right| \\leq \\left|\\frac{z-w}{1-\\overline{w}z}\\right|$$\\n$$|f'(z)| \\leq \\frac{1-|f(z)|^2}{1-|z|^2}$$\\n\\n**For $f\\colon \\mathbb{H}\\to \\mathbb{H}$**:\\n$$\\left|\\frac{f(z)-f(w)}{f(z)-\\overline{f(w)}}\\right| \\leq \\left|\\frac{z-w}{z-\\overline{w}}\\right|$$\\n$$|f'(z)| \\leq \\frac{\\Im (f(z))}{\\Im z}$$\\n\\n**For $f\\colon \\Delta \\to \\mathbb{H}$**:\\n$$\\left|\\frac{f(z)-f(w)}{f(z)-\\overline{f(w)}}\\right| \\leq \\left|\\frac{z-w}{1-\\overline{w}z}\\right|$$\\n$$|f'(z)| \\leq \\frac{2\\,\\Im (f(z))}{1-|z|^2}$$\\n\\n**For $f\\colon \\mathbb{H}\\to \\Delta$**:\\n$$\\left|\\frac{f(z)-f(w)}{1-\\overline{f(w)}f(z)}\\right| \\leq \\left|\\frac{z-w}{z-\\overline{w}}\\right|$$\\n$$|f'(z)| \\leq \\frac{1-|f(z)|^2}{2\\,\\Im z}$$"
                },
                {
                    id: 52,
                    category: "Conformal Geometry",
                    front: "State the triangle area formulas for constant curvature.",
                    back: "Let $T$ be a triangle with angles $A,B,C$. Then:\\n\\n‚Ä¢ **Spherical geometry** ($K = +1$): $\\text{area}(T) = A + B + C - \\pi$\\n\\n‚Ä¢ **Hyperbolic geometry** ($K = -1$): $\\text{area}(T) = \\pi - (A + B + C)$\\n\\n**Note**: In Euclidean geometry ($K = 0$), $A + B + C = \\pi$."
                },
                {
                    id: 53,
                    category: "Conformal Geometry",
                    front: "State the isometry groups of standard geometries.",
                    back: "‚Ä¢ **Euclidean**: $\\text{Iso}^+(\\mathbb{C}, \\rho) = \\{f(z) = az + b : a,b \\in \\mathbb{C}, |a| = 1\\}$\\n\\n‚Ä¢ **Spherical**: $\\text{Iso}^+(\\widehat{\\mathbb{C}}, \\rho_{\\widehat{\\mathbb{C}}}) \\simeq \\text{PSU}(2)$\\n\\n‚Ä¢ **Hyperbolic on $\\mathbb{H}$**: $\\text{Iso}^+(\\mathbb{H}, \\rho_\\mathbb{H}) = \\text{PSL}(2, \\mathbb{R})$\\n\\n‚Ä¢ **Hyperbolic on $\\Delta$**: $\\text{Iso}^+(\\Delta, \\rho_\\Delta) = \\text{PSU}(1,1)$"
                },
                {
                    id: 54,
                    category: "Conformal Geometry",
                    front: "State the Little Picard Theorem.",
                    back: "An **entire function** that **misses two values** is **constant**.\\n\\n**Proof**: If $f$ misses two points $a,b$, then $f: \\mathbb{C} \\to \\mathbb{C} \\setminus \\{a,b\\}$ is analytic. Since $\\mathbb{C} \\setminus \\{a,b\\}$ is hyperbolic, lift $f$ to analytic map $\\tilde{f}: \\mathbb{C} \\to \\Delta$. Thus $\\tilde{f}$ is constant by Liouville's Theorem, so $f$ is constant."
                },
                {
                    id: 55,
                    category: "Conformal Geometry",
                    front: "State the Great Picard Theorem.",
                    back: "Let $f: U \\setminus \\{p\\} \\to \\mathbb{C}$ be analytic with an **essential singularity** at $p$. Then $f$ takes on **every value** in $\\mathbb{C}$ except possibly **1** in every neighborhood of $p$.\\n\\n This strengthens Casorati-Weierstrass: near an essential singularity, $f$ not only gets dense in $\\mathbb{C}$, but actually hits every value except at most one."
                },

                // Section 5: Univalent Maps  
                {
                    id: 56,
                    category: "Univalent Maps",
                    front: "Define normal families and equicontinuity.",
                    back: "Let $C(U)$ be the set of continuous complex functions on $U\\subseteq \\mathbb{C}$.\\n\\n‚Ä¢ A family $\\mathcal{F}\\subset C(U)$ is **equicontinuous** on $E\\subseteq U$ if given any $\\epsilon > 0$, there exists $\\delta > 0$ such that $|f(z) - f(w)| < \\epsilon$ whenever $|z-w|< \\delta$ where $z,w\\in E$.\\n\\n‚Ä¢ A family $\\mathcal{F}$ is **normal** in $U$ if every sequence $\\{f_n\\}\\subset \\mathcal{F}$ contains a subsequence which converges uniformly on every compact subset of $U$."
                },
                {
                    id: 57,
                    category: "Univalent Maps",
                    front: "State the Arzela-Ascoli Theorem.",
                    back: "A family of continuous functions $\\mathcal{F}$ on $U$ is **normal** if and only if:\\n\\n‚Ä¢ $\\mathcal{F}$ is **equicontinuous** on every compact subset of $U$\\n\\n‚Ä¢ $\\mathcal{F}$ is **pointwise bounded**, i.e. given $z\\in U$, there exist a $M$ such that $|f(z)|\\leq M$ for all $f\\in \\mathcal{F}$"
                },
                {
                    id: 58,
                    category: "Univalent Maps",
                    front: "State Montel's Theorem.",
                    back: "**Conditions for normality** of analytic function families:\\n\\n‚Ä¢ Let $\\mathcal{F}$ be a family of **meromorphic maps** on $U\\subseteq \\mathbb{C}$ which **misses three values** of $\\widehat{\\mathbb{C}}$. Then $\\mathcal{F}$ is a normal family.\\n\\n‚Ä¢ Let $\\mathcal{F}$ be a family of **analytic functions** on $U\\subseteq \\mathbb{C}$ where each member of the family misses the same complex values $a,b\\in \\mathbb{C}$. Then $\\mathcal{F}$ is normal.\\n\\n‚Ä¢ A family $\\mathcal{F}$ of analytic functions on $U$ is normal $\\iff$ $\\mathcal{F}$ is uniformly bounded on every compact set."
                },
                {
                    id: 59,
                    category: "Univalent Maps",
                    front: "Define univalent functions and state convergence properties.",
                    back: "‚Ä¢ $f\\colon U\\to \\mathbb{C}$ is **locally univalent** if $f'\\neq 0$ on $U$\\n\\n‚Ä¢ $f\\colon U\\to \\mathbb{C}$ is **univalent** if it is locally univalent and injective\\n\\n**Convergence Theorem**: Let $f_n\\colon U\\to \\mathbb{C}$ be univalent maps converging to $f$ uniformly on compact subsets. Then $f$ is either **constant** or **univalent**."
                },
                {
                    id: 60,
                    category: "Univalent Maps",
                    front: "State Hurwitz's Theorem.",
                    back: "‚Ä¢ Let $f_n\\colon U\\to \\mathbb{C}$ be a sequence of analytic functions on a connected $U$ such that $f_n(z) \\neq 0$ for $z\\in U$ and $f_n\\to f$ uniformly on compact subsets. Then either $f\\equiv 0$ or $f$ is **never zero**.\\n\\n‚Ä¢ Let $f_n\\colon U\\to \\widehat{\\mathbb{C}}$ be meromorphic functions converging uniformly $f_n\\to f$ on compact subsets with respect to the spherical metric. Then either $f\\equiv \\infty$ or $f$ is meromorphic.\\n\\n‚Ä¢ A family $\\mathcal{F}$ of analytic functions is normal $\\iff$ every sequence either converges uniformly on compact subsets to an analytic function, or converges uniformly to $\\infty$."
                },
                {
                    id: 61,
                    category: "Univalent Maps",
                    front: "State the Koebe 1/4 Theorem.",
                    back: "If $f:\\Delta \\to \\mathbb{C}$ is **univalent** and **normalized** so that $f(0)=0$ and $f'(0)=1$, then $$f(\\Delta) \\supseteq \\{ w \\in \\mathbb{C} : |w| < 1/4 \\}$$\\n\\n This gives the **largest disk** guaranteed to be contained in the image of any normalized univalent function on the unit disk."
                },
                {
                    id: 62,
                    category: "Univalent Maps",
                    front: "State the Distortion Theorem.",
                    back: "If $f:\\Delta \\to \\mathbb{C}$ is univalent, $f(0)=0$, and $f'(0)=1$, then for every $z \\in \\Delta$:\\n\\n$$\\frac{|z|}{(1+|z|)^2} \\;\\leq\\; |f(z)| \\;\\leq\\; \\frac{|z|}{(1-|z|)^2}$$\\n\\n$$\\frac{1-|z|}{(1+|z|)^3} \\;\\leq\\; |f'(z)| \\;\\leq\\; \\frac{1+|z|}{(1-|z|)^3}$$\\n\\n These give **sharp bounds** on the growth of normalized univalent functions."
                },
                {
                    id: 63,
                    category: "Univalent Maps",
                    front: "State the Bieberbach Conjecture (de Branges Theorem).",
                    back: "If $f(z) = z + a_2 z^2 + a_3 z^3 + \\dots$ is **univalent** on $\\Delta$, then $$|a_n| \\leq n \\quad \\text{for all } n \\geq 2$$\\n\\n**Equality** holds precisely for rotations of the **Koebe function** $$k(z) = \\frac{z}{(1-z)^2}$$\\n\\n This fundamental result was conjectured in 1916 and proved by Louis de Branges in 1985."
                },

                // Section 6: Riemann Surfaces
                {
                    id: 64,
                    category: "Riemann Surfaces",
                    front: "State the local normal form for holomorphic maps.",
                    back: "**Lemma**: Let $f: U \\to \\mathbb{C}$ be a non-zero holomorphic map with $f(0)=0$. Then there exists a unique $k \\in \\mathbb{Z}_+$ such that there is an open subset $V \\subseteq U$ containing $0$ and a holomorphic map $g: V \\to \\mathbb{C}$ with $g(0)=0$, $g'(0)\\neq 0$, and $$f(z) = \\big(g(z)\\big)^k$$\\n\\n**Corollary**: In local coordinates, $f$ can be written as $\\tilde{f}(z) = z^k$ where $k$ is the **index** of the point."
                },
                {
                    id: 65,
                    category: "Riemann Surfaces",
                    front: "Define critical points, degree, and the Riemann-Hurwitz formula.",
                    back: "Given $f: X \\to Y$ with $f(x) = y$, let $k_x$ be the local degree at $x$.\\n\\n‚Ä¢ If $k_x > 1$, then $x$ is a **critical point** of order $k_x - 1$ and $y$ is a **critical value**\\n\\n‚Ä¢ The **degree of $y$**: $d(y) = \\sum_{x \\in f^{-1}(y)} k_x$\\n\\n**Riemann-Hurwitz Formula**: If $X, Y$ are compact Riemann surfaces and $f: X \\to Y$ has degree $d$, then $$\\chi(X) = d \\cdot \\chi(Y) - R_f$$ where $R_f = \\sum_x (k_x - 1)$ counts ramification."
                },
                {
                    id: 66,
                    category: "Riemann Surfaces",
                    front: "State the simple pole biholomorphism lemma.",
                    back: "Let $f\\colon X\\to \\widehat{\\mathbb{C}}$ be a meromorphic function on a **compact Riemann surface**. If $f$ has **1 pole which is simple**, then $f$ is a **biholomorphism** to $\\widehat{\\mathbb{C}}$.\\n\\n**Proof**: Let $f$ have a single simple pole at $p$. Then $k_p=1$ and $d(\\infty)=k_p=1$. Thus, $f$ has degree $d=1$ and is a bijection. Since $X$ is compact, $f$ has continuous inverse, and the inverse is holomorphic."
                },
                {
                    id: 67,
                    category: "Riemann Surfaces",
                    front: "Define holomorphic differentials and residues on Riemann surfaces.",
                    back: "‚Ä¢ A complex $1$-form $\\omega\\in \\Omega^1(X)$ is a **holomorphic differential** if in a coordinate chart $\\omega = f(z) dz$ where $f$ is holomorphic\\n\\n‚Ä¢ If $\\omega$ is meromorphic, with a pole at $p \\in X$, then there is a local expansion $$\\omega = f(z)\\,dz = \\sum_{k=-n}^\\infty a_k z^k\\,dz$$\\n\\n‚Ä¢ The coefficient $a_{-1}$ is the **residue** of $\\omega$ at $p$: $\\text{Res}(\\omega,p) = a_{-1}$"
                },
                {
                    id: 68,
                    category: "Riemann Surfaces",
                    front: "State the residue sum theorem for compact Riemann surfaces.",
                    back: "Let $\\omega$ be a **meromorphic one-form** on a **compact Riemann surface** $X$. Then the sum of the residues of $\\omega$ on $X$ is **zero**: $$\\sum_{p \\in X} \\text{Res}(\\omega,p) = 0$$\\n\\n**Proof**: Take small disjoint disks around the poles of $\\omega$, and let $U$ be the complement. Then $\\omega$ is holomorphic on a neighborhood of $U$, so $\\int_{\\partial U} \\omega = 0$. This implies the sum of the boundary integrals around the disks (i.e., residues) vanishes."
                },
                {
                    id: 69,
                    category: "Riemann Surfaces",
                    front: "State the zeros and poles count theorem.",
                    back: "If $f$ is a **meromorphic function** on a **compact Riemann surface** $X$, then $$N(f) - P(f) = 0$$ where $N(f) =$ number of zeros and $P(f) =$ number of poles (with multiplicity).\\n\\n**Proof**: $\\frac{df}{f}$ is a meromorphic one-form, with poles at the zeros and poles of $f$, and with residue equal to the order of the point. By the residue theorem: $$N(f) - P(f) = \\sum \\text{Res}\\left(\\frac{f'}{f}, p\\right) = 0$$"
                }
            ];

            // ========================================
            // UI CONFIGURATION & THEME
            // ========================================
            const categoryColors = {
                "Basics": "bg-blue-100 text-blue-800",
                "Integration": "bg-green-100 text-green-800", 
                "Riemann Mapping": "bg-purple-100 text-purple-800",
                "Conformal Geometry": "bg-red-100 text-red-800",
                "Univalent Maps": "bg-yellow-100 text-yellow-800",
                "Riemann Surfaces": "bg-indigo-100 text-indigo-800"
            };

            // ========================================
            // MAIN FLASHCARD APPLICATION COMPONENT
            // ========================================
            function FlashcardApp() {
                const [currentIndex, setCurrentIndex] = useState(0);
                const [showAnswer, setShowAnswer] = useState(false);
                const [hideAnswerText, setHideAnswerText] = useState(false);
                const [selectedCategories, setSelectedCategories] = useState(new Set(Object.keys(categoryColors)));
                const [filteredCards, setFilteredCards] = useState(flashcardsData);
                const [progress, setProgress] = useState({});
                const [showProgress, setShowProgress] = useState(true);
                const [isShuffled, setIsShuffled] = useState(false);
                const [shuffledIndices, setShuffledIndices] = useState([]);
                const [isDarkMode, setIsDarkMode] = useState(true);
                const [reviewMode, setReviewMode] = useState(false);
                const [showReviewPrompt, setShowReviewPrompt] = useState(false);
                const [deckCompleted, setDeckCompleted] = useState(false);
                const [showCelebration, setShowCelebration] = useState(false);

                const categories = Object.keys(categoryColors);

                // Apply dark mode to entire page body
                useEffect(() => {
                    document.body.className = isDarkMode ? 'bg-gray-900' : 'bg-gray-50';
                }, [isDarkMode]);

                // Configure and trigger MathJax rendering
                useEffect(() => {
                    const renderMath = async () => {
                        if (window.MathJax && window.MathJax.typesetPromise) {
                            try {
                                // Clear any existing MathJax processing first
                                if (window.MathJax.typesetClear) {
                                    window.MathJax.typesetClear();
                                }
                                // Add a small delay to let React finish DOM updates
                                await new Promise(resolve => setTimeout(resolve, 10));
                                await window.MathJax.typesetPromise();
                            } catch (err) {
                                console.log('MathJax rendering error:', err);
                                // Try to recover by clearing MathJax state
                                try {
                                    if (window.MathJax.startup && window.MathJax.startup.document) {
                                        window.MathJax.startup.document.state(0);
                                    }
                                } catch (recoveryErr) {
                                    console.log('MathJax recovery failed:', recoveryErr);
                                }
                            }
                        }
                    };
                    renderMath();
                }, [currentIndex, showAnswer, hideAnswerText, filteredCards]);

                useEffect(() => {
                    const filtered = flashcardsData.filter(card => selectedCategories.has(card.category));
                    setFilteredCards(filtered);
                    setCurrentIndex(0);
                    setShowAnswer(false);
                    setHideAnswerText(false);
                    setIsShuffled(false);
                    setShuffledIndices([]);
                    setReviewMode(false);
                    setShowReviewPrompt(false);
                    setDeckCompleted(false);
                    setShowCelebration(false);
                }, [selectedCategories]);

                // ========================================
                // UTILITY FUNCTIONS
                // ========================================
                
                // Fisher-Yates shuffle algorithm
                const shuffleArray = (array) => {
                    const shuffled = [...array];
                    for (let i = shuffled.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                    }
                    return shuffled;
                };

                const currentCard = isShuffled && shuffledIndices.length > 0 
                    ? filteredCards[shuffledIndices[currentIndex]] 
                    : filteredCards[currentIndex];
                
                // Create a defensive copy of the current card to prevent any reference issues
                const safeCurrentCard = currentCard ? {
                    ...currentCard,
                    front: String(currentCard.front || ''),
                    back: String(currentCard.back || '')
                } : null;

                const nextCard = () => {
                    if (currentIndex < filteredCards.length - 1) {
                        setCurrentIndex(currentIndex + 1);
                        setShowAnswer(false);
                        setHideAnswerText(false);
                    } else {
                        // Reached end of deck
                        setDeckCompleted(true);
                        triggerCelebration(); // üéâ Trigger celebration animation!
                        
                        const incorrectCards = getIncorrectCards();
                        if (incorrectCards.length > 0 && !reviewMode) {
                            // Delay showing the review prompt to let celebration play
                            setTimeout(() => {
                                setShowReviewPrompt(true);
                            }, 1500);
                        }
                    }
                };

                const prevCard = () => {
                    if (currentIndex > 0) {
                        setCurrentIndex(currentIndex - 1);
                        setShowAnswer(false);
                        setHideAnswerText(false);
                    }
                };

                const resetDeck = () => {
                    setCurrentIndex(0);
                    setShowAnswer(false);
                    setHideAnswerText(false);
                    setIsShuffled(false);
                    setShuffledIndices([]);
                    setDeckCompleted(false);
                    setShowReviewPrompt(false);
                    setShowCelebration(false);
                };

                const shuffleDeck = () => {
                    if (filteredCards.length > 0) {
                        const indices = Array.from({length: filteredCards.length}, (_, i) => i);
                        const shuffled = shuffleArray(indices);
                        setShuffledIndices(shuffled);
                        setIsShuffled(true);
                        setCurrentIndex(0);
                        setShowAnswer(false);
                        setHideAnswerText(false);
                    }
                };

                const toggleCategory = (category) => {
                    const newSelected = new Set(selectedCategories);
                    if (newSelected.has(category)) {
                        newSelected.delete(category);
                    } else {
                        newSelected.add(category);
                    }
                    setSelectedCategories(newSelected);
                };

                const toggleDarkMode = () => {
                    setIsDarkMode(!isDarkMode);
                };

                const markCard = (correct) => {
                    if (safeCurrentCard) {
                        setProgress(prev => ({
                            ...prev,
                            [safeCurrentCard.id]: correct
                        }));
                    }
                };

                const getProgressStats = () => {
                    const correct = Object.values(progress).filter(Boolean).length;
                    const total = Object.keys(progress).length;
                    return { correct, total };
                };

                const getIncorrectCards = () => {
                    return flashcardsData.filter(card => 
                        selectedCategories.has(card.category) && 
                        progress[card.id] === false
                    );
                };

                const startReviewMode = () => {
                    const incorrectCards = getIncorrectCards();
                    setFilteredCards(incorrectCards);
                    setReviewMode(true);
                    setShowReviewPrompt(false);
                    setCurrentIndex(0);
                    setShowAnswer(false);
                    setHideAnswerText(false);
                    setDeckCompleted(false);
                    setIsShuffled(false);
                    setShuffledIndices([]);
                };

                const exitReviewMode = () => {
                    const filtered = flashcardsData.filter(card => selectedCategories.has(card.category));
                    setFilteredCards(filtered);
                    setReviewMode(false);
                    setShowReviewPrompt(false);
                    setCurrentIndex(0);
                    setShowAnswer(false);
                    setHideAnswerText(false);
                    setDeckCompleted(false);
                    setIsShuffled(false);
                    setShuffledIndices([]);
                };

                const triggerCelebration = () => {
                    setShowCelebration(true);
                    // Hide celebration after 4 seconds
                    setTimeout(() => {
                        setShowCelebration(false);
                    }, 4000);
                };

                const createConfetti = () => {
                    const confettiElements = [];
                    const confettiEmojis = ['üéâ', 'üéä', '‚≠ê', '‚ú®', 'üåü', 'üí´', 'üéà', 'üéÜ', 'üéá', 'üåà', 'üéÅ', 'üçæ', 'ü•≥', 'üå∫', 'ü¶Ñ', 'üéÄ'];
                    
                    // Create explosive burst from center
                    for (let i = 0; i < 80; i++) {
                        const delay = Math.random() * 800;
                        const angle = (Math.PI * 2 * i) / 80 + Math.random() * 0.5;
                        const velocity = 300 + Math.random() * 400;
                        const endX = Math.cos(angle) * velocity;
                        const endY = Math.sin(angle) * velocity;
                        
                        const emoji = confettiEmojis[Math.floor(Math.random() * confettiEmojis.length)];
                        const size = 20 + Math.random() * 15;
                        
                        // Create unique keyframes for each confetti piece
                        const animationName = `explode-${i}`;
                        const keyframes = `
                            @keyframes ${animationName} {
                                0% {
                                    transform: translate(-50%, -50%) scale(0) rotate(0deg);
                                    opacity: 1;
                                }
                                15% {
                                    transform: translate(-50%, -50%) scale(1.2) rotate(180deg);
                                    opacity: 1;
                                }
                                100% {
                                    transform: translate(calc(-50% + ${endX}px), calc(-50% + ${endY}px)) scale(0.3) rotate(720deg);
                                    opacity: 0;
                                }
                            }
                        `;
                        
                        // Add keyframes to document
                        if (!document.getElementById(`style-${animationName}`)) {
                            const style = document.createElement('style');
                            style.id = `style-${animationName}`;
                            style.textContent = keyframes;
                            document.head.appendChild(style);
                        }
                        
                        confettiElements.push(
                            React.createElement('div', {
                                key: i,
                                className: 'confetti',
                                style: {
                                    left: '50%',
                                    top: '50%',
                                    fontSize: `${size}px`,
                                    animation: `${animationName} 2.5s ease-out forwards`,
                                    animationDelay: `${delay}ms`
                                }
                            }, emoji)
                        );
                    }
                    
                    // Add secondary bursts from corners
                    const burstPoints = [
                        { x: '20%', y: '20%' },
                        { x: '80%', y: '20%' },
                        { x: '20%', y: '80%' },
                        { x: '80%', y: '80%' }
                    ];
                    
                    burstPoints.forEach((point, pointIndex) => {
                        for (let i = 0; i < 15; i++) {
                            const delay = 600 + Math.random() * 1000;
                            const angle = Math.random() * Math.PI * 2;
                            const velocity = 150 + Math.random() * 250;
                            const endX = Math.cos(angle) * velocity;
                            const endY = Math.sin(angle) * velocity;
                            
                            const emoji = confettiEmojis[Math.floor(Math.random() * confettiEmojis.length)];
                            const size = 15 + Math.random() * 10;
                            
                            const animationName = `burst-${pointIndex}-${i}`;
                            const keyframes = `
                                @keyframes ${animationName} {
                                    0% {
                                        transform: scale(0) rotate(0deg);
                                        opacity: 1;
                                    }
                                    20% {
                                        transform: scale(1.1) rotate(180deg);
                                        opacity: 1;
                                    }
                                    100% {
                                        transform: translate(${endX}px, ${endY}px) scale(0.2) rotate(540deg);
                                        opacity: 0;
                                    }
                                }
                            `;
                            
                            if (!document.getElementById(`style-${animationName}`)) {
                                const style = document.createElement('style');
                                style.id = `style-${animationName}`;
                                style.textContent = keyframes;
                                document.head.appendChild(style);
                            }
                            
                            confettiElements.push(
                                React.createElement('div', {
                                    key: `burst-${pointIndex}-${i}`,
                                    className: 'confetti',
                                    style: {
                                        left: point.x,
                                        top: point.y,
                                        fontSize: `${size}px`,
                                        animation: `${animationName} 2s ease-out forwards`,
                                        animationDelay: `${delay}ms`
                                    }
                                }, emoji)
                            );
                        }
                    });
                    
                    return confettiElements;
                };

                const formatText = (text, cardId) => {
                    if (!text) return '';
                    
                    // Create a defensive copy to avoid any reference issues
                    const textCopy = String(text);
                    
                    // Convert \\n to actual newlines, but be careful not to break LaTeX commands
                    // Only replace \\n when it's NOT followed by a letter (to avoid breaking \\nu, \\nabla, etc.)
                    const processedText = textCopy.replace(/\\n(?![a-zA-Z])/g, '\n');
                    
                    // Split by lines but preserve display math blocks
                    const lines = [];
                    let currentBlock = '';
                    let inDisplayMath = false;
                    
                    for (const line of processedText.split('\n')) {
                        if (line.includes('$$')) {
                            const dollarsCount = (line.match(/\$\$/g) || []).length;
                            if (dollarsCount === 2) {
                                // Line contains both opening and closing $$
                                lines.push(currentBlock);
                                lines.push(line);
                                currentBlock = '';
                            } else if (dollarsCount === 1) {
                                if (inDisplayMath) {
                                    // Closing display math
                                    currentBlock += '\n' + line;
                                    lines.push(currentBlock);
                                    currentBlock = '';
                                    inDisplayMath = false;
                                } else {
                                    // Opening display math
                                    if (currentBlock.trim()) {
                                        lines.push(currentBlock);
                                    }
                                    currentBlock = line;
                                    inDisplayMath = true;
                                }
                            }
                        } else if (inDisplayMath) {
                            currentBlock += '\n' + line;
                        } else {
                            if (currentBlock) {
                                currentBlock += '\n' + line;
                            } else {
                                currentBlock = line;
                            }
                            if (!inDisplayMath && currentBlock.trim()) {
                                lines.push(currentBlock);
                                currentBlock = '';
                            }
                        }
                    }
                    
                    if (currentBlock.trim()) {
                        lines.push(currentBlock);
                    }
                    
                    return lines.map((block, blockIndex) => {
                        if (!block || block.trim() === '') {
                            return React.createElement('div', { key: `card-${cardId}-block-${blockIndex}`, className: "h-2" });
                        }
                        
                        // Handle blocks that contain display math ($$...$$)
                        if (block.includes('$$')) {
                            // Check if it's a pure display math block (starts with $$)
                            if (block.trim().startsWith('$$')) {
                                // Pure display math block - process bold formatting
                                const processBoldInMath = (text) => {
                                    const parts = [];
                                    const boldRegex = /\*\*([^*]+)\*\*/g;
                                    let lastIndex = 0;
                                    let match;
                                    let keyIndex = 0;
                                    
                                    while ((match = boldRegex.exec(text)) !== null) {
                                        // Add text before bold
                                        if (match.index > lastIndex) {
                                            parts.push(text.substring(lastIndex, match.index));
                                        }
                                        
                                        // Add bold text
                                        parts.push(
                                            React.createElement('strong', {
                                                key: `card-${cardId}-math-bold-${keyIndex}`,
                                                style: { fontWeight: 'bold' }
                                            }, match[1])
                                        );
                                        
                                        lastIndex = match.index + match[0].length;
                                        keyIndex++;
                                    }
                                    
                                    // Add remaining text
                                    if (lastIndex < text.length) {
                                        parts.push(text.substring(lastIndex));
                                    }
                                    
                                    return parts.length > 0 ? parts : text;
                                };
                                
                                return React.createElement('div', { 
                                    key: `card-${cardId}-block-${blockIndex}`, 
                                    className: "mb-4" 
                                }, processBoldInMath(block));
                            } else {
                                // Mixed content with display math - split and process parts
                                const parts = [];
                                const displayMathRegex = /\$\$([\s\S]*?)\$\$/g;
                                let lastIndex = 0;
                                let match;
                                let keyIndex = 0;
                                
                                while ((match = displayMathRegex.exec(block)) !== null) {
                                    // Add text before display math
                                    if (match.index > lastIndex) {
                                        const beforeText = block.substring(lastIndex, match.index);
                                        if (beforeText.trim()) {
                                            parts.push(
                                                React.createElement('span', {
                                                    key: `card-${cardId}-before-${keyIndex}`
                                                }, beforeText)
                                            );
                                        }
                                    }
                                    
                                    // Add display math block  
                                    parts.push(
                                        React.createElement('div', {
                                            key: `card-${cardId}-math-${keyIndex}`,
                                            className: "my-2"
                                        }, `$$${match[1]}$$`)
                                    );
                                    
                                    lastIndex = match.index + match[0].length;
                                    keyIndex++;
                                }
                                
                                // Add remaining text
                                if (lastIndex < block.length) {
                                    const remainingText = block.substring(lastIndex);
                                    if (remainingText.trim()) {
                                        parts.push(
                                            React.createElement('span', {
                                                key: `card-${cardId}-after-${keyIndex}`
                                            }, remainingText)
                                        );
                                    }
                                }
                                
                                // Process bold formatting, bullets, and numbered lists in the parts
                                const processedParts = parts.map((part, partIndex) => {
                                    if (typeof part === 'string') {
                                        const processTextWithFormatting = (text) => {
                                            // Check for bullet pattern at start
                                            const bulletMatch = text.match(/^(\s*)(‚Ä¢|\*|-)\s+(.*)$/);
                                            if (bulletMatch) {
                                                const indentation = bulletMatch[1];
                                                const isNested = indentation.length > 0;
                                                
                                                const processBoldText = (innerText) => {
                                                    const textParts = [];
                                                    const boldRegex = /\*\*([^*]+)\*\*/g;
                                                    let lastIdx = 0;
                                                    let boldMatch;
                                                    let boldKeyIdx = 0;
                                                    
                                                    while ((boldMatch = boldRegex.exec(innerText)) !== null) {
                                                        if (boldMatch.index > lastIdx) {
                                                            textParts.push(innerText.substring(lastIdx, boldMatch.index));
                                                        }
                                                        
                                                        textParts.push(
                                                            React.createElement('strong', {
                                                                key: `bold-${partIndex}-${boldKeyIdx}`,
                                                                style: { fontWeight: 'bold' }
                                                            }, boldMatch[1])
                                                        );
                                                        
                                                        lastIdx = boldMatch.index + boldMatch[0].length;
                                                        boldKeyIdx++;
                                                    }
                                                    
                                                    if (lastIdx < innerText.length) {
                                                        textParts.push(innerText.substring(lastIdx));
                                                    }
                                                    
                                                    return textParts.length > 0 ? textParts : innerText;
                                                };
                                                
                                                // Return structured bullet item
                                                return [
                                                    React.createElement('span', {
                                                        key: `bullet-${partIndex}`,
                                                        className: `mr-3 flex-shrink-0 ${isNested ? 'text-gray-500' : 'text-blue-600'}`
                                                    }, isNested ? '-' : '‚Ä¢'),
                                                    ...processBoldText(bulletMatch[3])
                                                ];
                                            }
                                            
                                            // Check for numbered list pattern at start
                                            const numberMatch = text.match(/^(\d+\.\s*)(.*)$/);
                                            if (numberMatch) {
                                                const processBoldText = (innerText) => {
                                                    const textParts = [];
                                                    const boldRegex = /\*\*([^*]+)\*\*/g;
                                                    let lastIdx = 0;
                                                    let boldMatch;
                                                    let boldKeyIdx = 0;
                                                    
                                                    while ((boldMatch = boldRegex.exec(innerText)) !== null) {
                                                        if (boldMatch.index > lastIdx) {
                                                            textParts.push(innerText.substring(lastIdx, boldMatch.index));
                                                        }
                                                        
                                                        textParts.push(
                                                            React.createElement('strong', {
                                                                key: `bold-${partIndex}-${boldKeyIdx}`,
                                                                style: { fontWeight: 'bold' }
                                                            }, boldMatch[1])
                                                        );
                                                        
                                                        lastIdx = boldMatch.index + boldMatch[0].length;
                                                        boldKeyIdx++;
                                                    }
                                                    
                                                    if (lastIdx < innerText.length) {
                                                        textParts.push(innerText.substring(lastIdx));
                                                    }
                                                    
                                                    return textParts.length > 0 ? textParts : innerText;
                                                };
                                                
                                                // Return structured numbered item
                                                return [
                                                    React.createElement('span', {
                                                        key: `number-${partIndex}`,
                                                        className: "font-bold text-blue-600 mr-2"
                                                    }, numberMatch[1]),
                                                    ...processBoldText(numberMatch[2])
                                                ];
                                            } else {
                                                // Regular text processing
                                                const textParts = [];
                                                const boldRegex = /\*\*([^*]+)\*\*/g;
                                                let lastIdx = 0;
                                                let boldMatch;
                                                let boldKeyIdx = 0;
                                                
                                                while ((boldMatch = boldRegex.exec(text)) !== null) {
                                                    if (boldMatch.index > lastIdx) {
                                                        textParts.push(text.substring(lastIdx, boldMatch.index));
                                                    }
                                                    
                                                    textParts.push(
                                                        React.createElement('strong', {
                                                            key: `bold-${partIndex}-${boldKeyIdx}`,
                                                            style: { fontWeight: 'bold' }
                                                        }, boldMatch[1])
                                                    );
                                                    
                                                    lastIdx = boldMatch.index + boldMatch[0].length;
                                                    boldKeyIdx++;
                                                }
                                                
                                                if (lastIdx < text.length) {
                                                    textParts.push(text.substring(lastIdx));
                                                }
                                                
                                                return textParts.length > 0 ? textParts : text;
                                            }
                                        };
                                        return processTextWithFormatting(text);
                                    }
                                    
                                    // For React elements, check if they have string content and process
                                    if (React.isValidElement(part) && typeof part.props.children === 'string') {
                                        const processTextWithFormatting = (text) => {
                                            // Check for bullet pattern at start
                                            const bulletMatch = text.match(/^(\s*)(‚Ä¢|\*|-)\s+(.*)$/);
                                            if (bulletMatch) {
                                                const indentation = bulletMatch[1];
                                                const isNested = indentation.length > 0;
                                                
                                                const processBoldText = (innerText) => {
                                                    const textParts = [];
                                                    const boldRegex = /\*\*([^*]+)\*\*/g;
                                                    let lastIdx = 0;
                                                    let boldMatch;
                                                    let boldKeyIdx = 0;
                                                    
                                                    while ((boldMatch = boldRegex.exec(innerText)) !== null) {
                                                        if (boldMatch.index > lastIdx) {
                                                            textParts.push(innerText.substring(lastIdx, boldMatch.index));
                                                        }
                                                        
                                                        textParts.push(
                                                            React.createElement('strong', {
                                                                key: `bold-${partIndex}-${boldKeyIdx}`,
                                                                style: { fontWeight: 'bold' }
                                                            }, boldMatch[1])
                                                        );
                                                        
                                                        lastIdx = boldMatch.index + boldMatch[0].length;
                                                        boldKeyIdx++;
                                                    }
                                                    
                                                    if (lastIdx < innerText.length) {
                                                        textParts.push(innerText.substring(lastIdx));
                                                    }
                                                    
                                                    return textParts.length > 0 ? textParts : innerText;
                                                };
                                                
                                                // Return structured bullet item
                                                return [
                                                    React.createElement('span', {
                                                        key: `bullet-${partIndex}`,
                                                        className: `mr-3 flex-shrink-0 ${isNested ? 'text-gray-500' : 'text-blue-600'}`
                                                    }, isNested ? '-' : '‚Ä¢'),
                                                    ...processBoldText(bulletMatch[3])
                                                ];
                                            }
                                            
                                            // Check for numbered list pattern at start
                                            const numberMatch = text.match(/^(\d+\.\s*)(.*)$/);
                                            if (numberMatch) {
                                                const processBoldText = (innerText) => {
                                                    const textParts = [];
                                                    const boldRegex = /\*\*([^*]+)\*\*/g;
                                                    let lastIdx = 0;
                                                    let boldMatch;
                                                    let boldKeyIdx = 0;
                                                    
                                                    while ((boldMatch = boldRegex.exec(innerText)) !== null) {
                                                        if (boldMatch.index > lastIdx) {
                                                            textParts.push(innerText.substring(lastIdx, boldMatch.index));
                                                        }
                                                        
                                                        textParts.push(
                                                            React.createElement('strong', {
                                                                key: `bold-${partIndex}-${boldKeyIdx}`,
                                                                style: { fontWeight: 'bold' }
                                                            }, boldMatch[1])
                                                        );
                                                        
                                                        lastIdx = boldMatch.index + boldMatch[0].length;
                                                        boldKeyIdx++;
                                                    }
                                                    
                                                    if (lastIdx < innerText.length) {
                                                        textParts.push(innerText.substring(lastIdx));
                                                    }
                                                    
                                                    return textParts.length > 0 ? textParts : innerText;
                                                };
                                                
                                                // Return structured numbered item
                                                return [
                                                    React.createElement('span', {
                                                        key: `number-${partIndex}`,
                                                        className: "font-bold text-blue-600 mr-2"
                                                    }, numberMatch[1]),
                                                    ...processBoldText(numberMatch[2])
                                                ];
                                            } else {
                                                // Regular bold text processing
                                                const textParts = [];
                                                const boldRegex = /\*\*([^*]+)\*\*/g;
                                                let lastIdx = 0;
                                                let boldMatch;
                                                let boldKeyIdx = 0;
                                                
                                                while ((boldMatch = boldRegex.exec(text)) !== null) {
                                                    if (boldMatch.index > lastIdx) {
                                                        textParts.push(text.substring(lastIdx, boldMatch.index));
                                                    }
                                                    
                                                    textParts.push(
                                                        React.createElement('strong', {
                                                            key: `bold-${partIndex}-${boldKeyIdx}`,
                                                            style: { fontWeight: 'bold' }
                                                        }, boldMatch[1])
                                                    );
                                                    
                                                    lastIdx = boldMatch.index + boldMatch[0].length;
                                                    boldKeyIdx++;
                                                }
                                                
                                                if (lastIdx < text.length) {
                                                    textParts.push(text.substring(lastIdx));
                                                }
                                                
                                                return textParts.length > 0 ? textParts : text;
                                            }
                                        };
                                        
                                        const processedContent = processTextWithFormatting(part.props.children);
                                        return React.cloneElement(part, { 
                                            key: part.key,
                                            children: processedContent 
                                        });
                                    }
                                    
                                    return part;
                                });
                                
                                return React.createElement('div', { 
                                    key: `card-${cardId}-block-${blockIndex}`, 
                                    className: "mb-4" 
                                }, processedParts);
                            }
                        }
                        
                        
                        // Process block line by line
                        return block.split('\n').map((line, lineIndex) => {
                            const key = `card-${cardId}-${blockIndex}-${lineIndex}`;
                            
                            
                            // Skip empty lines but add spacing
                            if (line.trim() === '') {
                                return React.createElement('div', { key, className: "h-2" });
                            }
                            
                            // Handle **bold** formatting
                            const processBoldText = (text) => {
                                if (!text || typeof text !== 'string') return text;
                                
                                // Simple regex replacement approach
                                const parts = [];
                                const boldRegex = /\*\*([^*]+)\*\*/g;
                                let lastIndex = 0;
                                let match;
                                let keyIndex = 0;
                                
                                while ((match = boldRegex.exec(text)) !== null) {
                                    // Add text before bold
                                    if (match.index > lastIndex) {
                                        parts.push(text.substring(lastIndex, match.index));
                                    }
                                    
                                    // Add bold text
                                    parts.push(
                                        React.createElement('strong', {
                                            key: `card-${cardId}-bold-${keyIndex}`,
                                            style: { fontWeight: 'bold' }
                                        }, match[1])
                                    );
                                    
                                    lastIndex = match.index + match[0].length;
                                    keyIndex++;
                                }
                                
                                // Add remaining text
                                if (lastIndex < text.length) {
                                    parts.push(text.substring(lastIndex));
                                }
                                
                                return parts.length > 0 ? parts : text;
                            };
                            
                            // Handle bullet points (including nested ones)
                            const bulletMatch = line.match(/^(\s*)(‚Ä¢|\*|-)\s+(.*)$/);
                            if (bulletMatch) {
                                const indentation = bulletMatch[1];
                                const isNested = indentation.length > 0;
                                
                                return React.createElement('div', { 
                                    key, 
                                    className: `mb-2 flex items-start ${isNested ? 'ml-6' : ''}` 
                                }, [
                                    React.createElement('span', { 
                                        key: 'bullet',
                                        className: `mr-3 flex-shrink-0 ${isNested ? 'text-gray-500' : 'text-blue-600'}` 
                                    }, isNested ? '-' : '‚Ä¢'),
                                    React.createElement('div', { 
                                        key: 'content',
                                        className: "flex-1"
                                    }, processBoldText(bulletMatch[3]))
                                ]);
                            }
                            
                            // Handle numbered items like "1. content"  
                            const numberMatch = line.match(/^(\d+\.\s*)(.*)$/);
                            if (numberMatch) {
                                return React.createElement('div', { 
                                    key, 
                                    className: "mb-3 flex items-start" 
                                }, [
                                    React.createElement('span', { 
                                        key: 'number',
                                        className: "font-bold mr-3 flex-shrink-0 text-blue-600 min-w-6" 
                                    }, numberMatch[1]),
                                    React.createElement('div', { 
                                        key: 'content',
                                        className: "flex-1"
                                    }, processBoldText(numberMatch[2]))
                                ]);
                            }
                            
                            // Regular lines
                            return React.createElement('div', { key, className: "mb-1" }, processBoldText(line));
                        });
                    }).flat().filter(Boolean);
                };

                if (filteredCards.length === 0) {
                    const themeClasses = {
                        body: isDarkMode ? 'bg-gray-900 text-white' : 'bg-gray-50 text-gray-900',
                        text: {
                            primary: isDarkMode ? 'text-white' : 'text-gray-800',
                            secondary: isDarkMode ? 'text-gray-300' : 'text-gray-600',
                        },
                        button: {
                            secondary: isDarkMode ? 'bg-gray-700 hover:bg-gray-600' : 'bg-gray-200 hover:bg-gray-300',
                        }
                    };

                    return React.createElement('div', { className: `max-w-4xl mx-auto p-6 min-h-screen ${themeClasses.body}` },
                        React.createElement('div', { className: "mb-6" },
                            React.createElement('div', { className: "flex justify-between items-center mb-4" },
                                React.createElement('div', { className: "flex-1" },
                                    React.createElement('h1', { className: `text-3xl font-bold ${themeClasses.text.primary} text-center` },
                                        "Complex Analysis Flashcards"
                                    )
                                ),
                                React.createElement('button', {
                                    onClick: toggleDarkMode,
                                    className: `p-2 rounded-lg ${themeClasses.button.secondary} text-lg`
                                }, isDarkMode ? Sun() : Moon())
                            ),
                            
                            // Category Filter
                            React.createElement('div', { className: "mb-4" },
                                React.createElement('h3', { className: `text-lg font-medium ${themeClasses.text.primary} mb-2` }, 
                                    "Select Categories:"),
                                React.createElement('div', { className: "flex flex-wrap gap-2" },
                                    categories.map(category => 
                                        React.createElement('button', {
                                            key: category,
                                            onClick: () => toggleCategory(category),
                                            className: `px-3 py-1 rounded-full text-sm font-medium transition-all ${
                                                selectedCategories.has(category) 
                                                    ? categoryColors[category] 
                                                    : 'bg-gray-200 text-gray-500'
                                            }`
                                        }, category)
                                    )
                                )
                            ),
                            
                            React.createElement('div', { className: "text-center mt-8" },
                                React.createElement('p', { className: `${themeClasses.text.secondary} text-lg` }, 
                                    "Please select at least one category to study.")
                            )
                        )
                    );
                }

                if (!safeCurrentCard) {
                    return React.createElement('div', { className: `max-w-4xl mx-auto p-6 min-h-screen ${isDarkMode ? 'bg-gray-900' : 'bg-gray-50'}` },
                        React.createElement('div', { className: "text-center" },
                            React.createElement('h1', { className: `text-3xl font-bold ${isDarkMode ? 'text-white' : 'text-gray-800'} mb-4` }, 
                                "Complex Analysis Flashcards"),
                            React.createElement('p', { className: isDarkMode ? 'text-gray-300' : 'text-gray-600' }, "Loading cards...")
                        )
                    );
                }

                const { correct, total } = getProgressStats();

                // Theme-aware classes
                const themeClasses = {
                    body: isDarkMode ? 'bg-gray-900 text-white' : 'bg-gray-50 text-gray-900',
                    card: isDarkMode ? 'bg-gray-800 text-white' : 'bg-white text-gray-900',
                    cardContent: isDarkMode ? 'bg-gray-700' : 'bg-gray-50',
                    text: {
                        primary: isDarkMode ? 'text-white' : 'text-gray-800',
                        secondary: isDarkMode ? 'text-gray-300' : 'text-gray-600',
                        muted: isDarkMode ? 'text-gray-400' : 'text-gray-500'
                    },
                    button: {
                        primary: isDarkMode ? 'bg-blue-700 hover:bg-blue-800' : 'bg-blue-600 hover:bg-blue-700',
                        secondary: isDarkMode ? 'bg-gray-700 hover:bg-gray-600' : 'bg-gray-200 hover:bg-gray-300',
                        nav: isDarkMode ? 'bg-gray-700 hover:bg-gray-600' : 'bg-gray-600 hover:bg-gray-700',
                        purple: isDarkMode ? 'bg-purple-700 hover:bg-purple-800' : 'bg-purple-600 hover:bg-purple-700',
                        green: isDarkMode ? 'bg-green-700 hover:bg-green-800' : 'bg-green-100 hover:bg-green-200',
                        greenActive: isDarkMode ? 'bg-green-600 shadow-lg shadow-green-500/50' : 'bg-green-600 shadow-lg shadow-green-500/30',
                        red: isDarkMode ? 'bg-red-700 hover:bg-red-800' : 'bg-red-100 hover:bg-red-200',
                        redActive: isDarkMode ? 'bg-red-600 shadow-lg shadow-red-500/50' : 'bg-red-600 shadow-lg shadow-red-500/30'
                    },
                    progressBar: isDarkMode ? 'bg-gray-700' : 'bg-gray-200',
                    progressFill: isDarkMode ? 'bg-blue-500' : 'bg-blue-600'
                };

                return React.createElement('div', { className: `max-w-4xl mx-auto p-6 min-h-screen ${themeClasses.body}` },
                    // Celebration overlay
                    showCelebration && React.createElement('div', { className: "celebration-overlay" },
                        createConfetti()
                    ),
                    
                    React.createElement('div', { className: "mb-6" },
                        React.createElement('div', { className: "flex justify-between items-center mb-4" },
                            React.createElement('div', { className: "flex-1" },
                                React.createElement('h1', { className: `text-3xl font-bold ${themeClasses.text.primary} text-center` },
                                    "Complex Analysis Flashcards"
                                ),
                                reviewMode && React.createElement('div', { className: `text-center text-sm ${themeClasses.text.secondary} mt-1` },
                                    "üìù Review Mode - Incorrect Cards Only"
                                )
                            ),
                            React.createElement('button', {
                                onClick: toggleDarkMode,
                                className: `p-2 rounded-lg ${themeClasses.button.secondary} ${themeClasses.text.primary} transition-colors`,
                                title: isDarkMode ? 'Switch to light mode' : 'Switch to dark mode'
                            }, isDarkMode ? Sun() : Moon())
                        ),
                        
                        // Category Filter
                        React.createElement('div', { className: "mb-4" },
                            React.createElement('h3', { className: `text-lg font-medium ${themeClasses.text.primary} mb-2` }, 
                                "Select Categories:"),
                            React.createElement('div', { className: "flex flex-wrap gap-2" },
                                categories.map(category => 
                                    React.createElement('button', {
                                        key: category,
                                        onClick: () => toggleCategory(category),
                                        className: `px-3 py-1 rounded-full text-sm font-medium transition-all ${
                                            selectedCategories.has(category) 
                                                ? categoryColors[category] 
                                                : 'bg-gray-200 text-gray-500'
                                        }`
                                    }, category)
                                )
                            )
                        ),

                        // Controls Row
                        React.createElement('div', { className: "flex justify-between items-center mb-2" },
                            React.createElement('div', { className: `text-sm ${themeClasses.text.secondary}` },
                                `Card ${currentIndex + 1} of ${filteredCards.length}`,
                                isShuffled && React.createElement('span', { className: `ml-2 ${isDarkMode ? 'text-purple-400' : 'text-purple-600'}` }, "(Shuffled)")
                            ),
                            React.createElement('div', { className: "flex items-center gap-2" },
                                !reviewMode && React.createElement('button', {
                                    onClick: shuffleDeck,
                                    className: `flex items-center gap-2 px-3 py-1 ${themeClasses.button.purple} text-white rounded-lg text-sm transition-colors`
                                },
                                    React.createElement(Shuffle, { size: 16 }),
                                    "Shuffle"
                                ),
                                !reviewMode && getIncorrectCards().length > 0 && React.createElement('button', {
                                    onClick: startReviewMode,
                                    className: `flex items-center gap-2 px-3 py-1 ${themeClasses.button.red} ${isDarkMode ? 'text-red-300' : 'text-red-600'} rounded-lg text-sm transition-colors`
                                },
                                    React.createElement('span', null, 'üìù'),
                                    "Review Wrong"
                                ),
                                reviewMode && React.createElement('button', {
                                    onClick: exitReviewMode,
                                    className: `flex items-center gap-2 px-3 py-1 ${themeClasses.button.secondary} rounded-lg text-sm ${themeClasses.text.primary}`
                                },
                                    React.createElement('span', null, '‚Üê'),
                                    "Exit Review"
                                ),
                                React.createElement('button', {
                                    onClick: () => setShowProgress(!showProgress),
                                    className: `flex items-center gap-2 px-3 py-1 ${themeClasses.button.purple} text-white rounded-lg text-sm transition-colors`
                                },
                                    React.createElement(showProgress ? EyeOff : Eye, { size: 16 }),
                                    "Progress"
                                ),
                                React.createElement('button', {
                                    onClick: resetDeck,
                                    className: `flex items-center gap-2 px-3 py-1 ${themeClasses.button.purple} text-white rounded-lg text-sm transition-colors`
                                },
                                    React.createElement(RotateCcw, { size: 16 }),
                                    "Reset"
                                )
                            )
                        ),

                    ),

                    // Main Flashcard
                    React.createElement('div', { className: `${themeClasses.card} rounded-xl shadow-lg mb-6 min-h-96` },
                        React.createElement('div', { className: "p-6" },
                            // Category badge
                            React.createElement('div', { className: "flex justify-between items-center mb-4" },
                                React.createElement('div', {
                                    className: `px-3 py-1 rounded-full text-sm font-medium ${categoryColors[safeCurrentCard.category]}`
                                }, safeCurrentCard.category),
                                React.createElement('div', { className: "flex gap-2" },
                                    progress[safeCurrentCard.id] === true && React.createElement('div', { className: `w-6 h-6 rounded-full ${themeClasses.button.greenActive} flex items-center justify-center text-white text-sm` }, '‚úì'),
                                    progress[safeCurrentCard.id] === false && React.createElement('div', { className: `w-6 h-6 rounded-full ${themeClasses.button.redActive} flex items-center justify-center text-white text-sm` }, '‚úó')
                                )
                            ),
                            
                            // Question
                            React.createElement('div', { className: `${themeClasses.cardContent} rounded-lg p-4 mb-4` },
                                React.createElement('h2', { className: `text-xl font-semibold ${themeClasses.text.primary} mb-4` }, 
                                    "Question:"),
                                React.createElement('div', { className: `${themeClasses.text.primary} text-lg leading-relaxed` },
                                    formatText(safeCurrentCard.front, safeCurrentCard.id)
                                )
                            ),

                            // Answer (when revealed)
                            showAnswer && React.createElement('div', { className: `${themeClasses.cardContent} rounded-lg p-4 mb-4` },
                                React.createElement('h2', { className: `text-xl font-semibold ${themeClasses.text.primary} mb-4` }, 
                                    "Answer:"),
                                !hideAnswerText && React.createElement('div', { className: `${themeClasses.text.primary} text-lg leading-relaxed` },
                                    formatText(safeCurrentCard.back, safeCurrentCard.id)
                                ),
                                hideAnswerText && React.createElement('div', { className: `${themeClasses.text.secondary} text-center py-8 italic` },
                                    "Answer is hidden. Click 'Show' to reveal it."
                                )
                            ),

                            // Bottom buttons
                            React.createElement('div', { className: "flex justify-between items-center" },
                                // Left: Previous button
                                React.createElement('button', {
                                    onClick: prevCard,
                                    disabled: currentIndex === 0,
                                    className: `flex items-center gap-2 px-4 py-2 ${themeClasses.button.nav} text-white rounded-lg transition-colors ${
                                        currentIndex === 0 ? 'opacity-50 cursor-not-allowed' : ''
                                    }`
                                },
                                    React.createElement(ChevronLeft, null),
                                    "Previous"
                                ),

                                // Center: Show/Next buttons
                                React.createElement('div', { className: "flex gap-3" },
                                    !showAnswer ? 
                                        React.createElement('button', {
                                            onClick: () => setShowAnswer(true),
                                            className: `px-6 py-2 ${themeClasses.button.primary} text-white rounded-lg transition-colors`
                                        }, "Show Answer")
                                    :
                                        React.createElement('div', { className: "flex gap-3" },
                                            React.createElement('button', {
                                                onClick: () => setHideAnswerText(!hideAnswerText),
                                                className: `px-3 py-2 ${themeClasses.button.nav} text-white rounded-lg transition-colors flex items-center gap-2`,
                                                title: hideAnswerText ? "Show answer text" : "Hide answer text"
                                            }, 
                                                React.createElement(hideAnswerText ? Eye : EyeOff, null),
                                                hideAnswerText ? "Show" : "Hide"
                                            ),
                                            React.createElement('button', {
                                                onClick: () => markCard(false),
                                                className: `px-4 py-2 ${progress[safeCurrentCard.id] === false ? themeClasses.button.redActive : themeClasses.button.red} ${progress[safeCurrentCard.id] === false ? 'text-white font-semibold' : (isDarkMode ? 'text-red-300' : 'text-red-600')} rounded-lg transition-all`
                                            }, "Incorrect"),
                                            React.createElement('button', {
                                                onClick: () => markCard(true),
                                                className: `px-4 py-2 ${progress[safeCurrentCard.id] === true ? themeClasses.button.greenActive : themeClasses.button.green} ${progress[safeCurrentCard.id] === true ? 'text-white font-semibold' : (isDarkMode ? 'text-green-300' : 'text-green-600')} rounded-lg transition-all`
                                            }, "Correct")
                                        )
                                ),

                                // Right: Next button
                                React.createElement('button', {
                                    onClick: nextCard,
                                    className: `flex items-center gap-2 px-4 py-2 ${themeClasses.button.nav} text-white rounded-lg transition-colors`
                                },
                                    currentIndex === filteredCards.length - 1 ? "Finish" : "Next",
                                    React.createElement(ChevronRight, null)
                                )
                            )
                        )
                    ),

                    // Progress Bar (position in deck)
                    React.createElement('div', { className: `w-full ${themeClasses.progressBar} rounded-full h-2 mt-6` },
                        React.createElement('div', {
                            className: `${themeClasses.progressFill} h-2 rounded-full transition-all duration-300`,
                            style: { width: `${((currentIndex + 1) / filteredCards.length) * 100}%` }
                        })
                    ),

                    // Deck completed message
                    deckCompleted && React.createElement('div', { className: `text-center ${themeClasses.text.primary}` },
                        React.createElement('h3', { className: "text-2xl font-bold mb-4" }, "üéâ Deck Complete! üéâ"),
                        React.createElement('p', { className: `${themeClasses.text.secondary} mb-4` }, 
                            `You've finished studying ${filteredCards.length} cards!`),
                        React.createElement('div', { className: "flex justify-center gap-4" },
                            React.createElement('button', {
                                onClick: resetDeck,
                                className: `px-6 py-2 ${themeClasses.button.primary} text-white rounded-lg transition-colors`
                            }, "Study Again"),
                            !reviewMode && getIncorrectCards().length > 0 && React.createElement('button', {
                                onClick: startReviewMode,
                                className: `px-6 py-2 ${themeClasses.button.red} ${isDarkMode ? 'text-red-300' : 'text-red-600'} rounded-lg transition-colors`
                            }, `Review ${getIncorrectCards().length} Wrong`)
                        )
                    ),

                    // Review prompt
                    showReviewPrompt && React.createElement('div', { className: `${themeClasses.card} rounded-lg p-6 mt-4 text-center` },
                        React.createElement('h3', { className: `text-xl font-bold ${themeClasses.text.primary} mb-2` }, 
                            "Review Incorrect Cards?"),
                        React.createElement('p', { className: `${themeClasses.text.secondary} mb-4` }, 
                            `You got ${getIncorrectCards().length} cards wrong. Would you like to review them?`),
                        React.createElement('div', { className: "flex justify-center gap-4" },
                            React.createElement('button', {
                                onClick: startReviewMode,
                                className: `px-6 py-2 ${themeClasses.button.primary} text-white rounded-lg transition-colors`
                            }, "Yes, Review"),
                            React.createElement('button', {
                                onClick: () => setShowReviewPrompt(false),
                                className: `px-6 py-2 ${themeClasses.button.secondary} ${themeClasses.text.primary} rounded-lg transition-colors`
                            }, "No, Thanks")
                        )
                    ),

                    // Progress stats (when toggled)
                    showProgress && React.createElement('div', { className: `${themeClasses.card} rounded-lg p-3 mt-4` },
                        React.createElement('div', { className: `text-center ${themeClasses.text.primary}` },
                            `Progress: ${correct}/${total} correct${total > 0 ? ` (${Math.round((correct / total) * 100)}%)` : ''}`
                        )
                    )
                );
            }

            ReactDOM.render(React.createElement(FlashcardApp), document.getElementById('root'));

        } catch (error) {
            console.error('Flashcard App Error:', error);
            const errorHtml = `
                <div class="error">
                    <h2>Application Error</h2>
                    <p><strong>Error:</strong> ${error.message}</p>
                    <p>Please refresh the page to try again. If the problem persists, check the browser console for more details.</p>
                    <button onclick="window.location.reload()" style="margin-top: 10px; padding: 8px 16px; background: #3b82f6; color: white; border: none; border-radius: 4px; cursor: pointer;">
                        Reload Page
                    </button>
                </div>
            `;
            document.getElementById('root').innerHTML = errorHtml;
        }
    </script>
</body>
</html>